<script src="data.js"></script>
    <script>
        /* --- [설정] --- */
        const CATEGORY_ORDER = ["DRAMA", "MOVIE", "VARIETY", "AUDIOBOOK", "COMMERCIALS (ADS)"];
        const LANG_LIST = ['ko', 'en', 'cn', 'ja', 'pt', 'es', 'ar'];
        const LANG_LABEL = { ko:'한국어', en:'English', cn:'中文', ja:'日本語', pt:'Português', es:'Español', ar:'العربية' };

        let ghConfig = JSON.parse(localStorage.getItem('ghConfig')) || { owner: '', repo: '', token: '' };

        window.onload = function() {
            document.getElementById('confOwner').value = ghConfig.owner;
            document.getElementById('confRepo').value = ghConfig.repo;
            document.getElementById('confToken').value = ghConfig.token;
            
            if(typeof portfolioData !== 'undefined') {
                initAdmin();
            }
            
            if(ghConfig.owner && ghConfig.token) {
                forceLoadFromGitHub(true);
            }
        };

        function initAdmin() {
            document.getElementById('mainImagePreview').src = portfolioData.mainImage;
            renderGallery();
            renderFilmoGroups();
        }
        function toggleConfig() { document.getElementById('configPanel').classList.toggle('open'); }
        function saveConfig() {
            ghConfig = { owner: document.getElementById('confOwner').value.trim(), repo: document.getElementById('confRepo').value.trim(), token: document.getElementById('confToken').value.trim() };
            localStorage.setItem('ghConfig', JSON.stringify(ghConfig));
            alert("설정 저장 완료!"); toggleConfig();
            forceLoadFromGitHub();
        }

        /* ============================================================
           ★ [핵심 수정] 이미지 업로드 시 '즉시 미리보기(Base64)' 적용
           ============================================================ */
        
        // 1. 단일 이미지 업로드 (메인, 필모 썸네일)
        async function uploadImage(input, targetKey, index = null) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            showLoading(`이미지 업로드 중...`);

            try {
                // 1. 미리보기용 데이터 생성 (즉시 보임)
                const base64Content = await toBase64(file);
                
                // 2. 실제 업로드
                const fileName = `images/${new Date().getTime()}_${file.name}`;
                const uploadedUrl = await uploadFileToGitHub(fileName, base64Content);
                
                if (index !== null) {
                    // [필모그래피 썸네일]
                    portfolioData.filmography[index].thumb = uploadedUrl; // 데이터엔 URL 저장
                    renderFilmoGroups(); // UI 갱신
                    
                    // ★ 핵심: 갱신된 UI의 이미지를 강제로 Base64로 교체 (기다림 없이 보임)
                    setTimeout(() => {
                        const itemEl = document.querySelector(`.filmo-item[data-origin-index="${index}"]`);
                        if(itemEl) {
                            const img = itemEl.querySelector('.thumb-preview');
                            const preview = itemEl.querySelector('.preview-img');
                            if(img) img.src = base64Content;
                            if(preview) preview.src = base64Content;
                        }
                    }, 100);
                } else {
                    // [메인 이미지]
                    portfolioData[targetKey] = uploadedUrl;
                    document.getElementById('mainImagePreview').src = base64Content; // 즉시 교체
                }
                alert("업로드 성공! (미리보기가 적용되었습니다)");

            } catch (err) {
                alert("실패: " + err.message);
            } finally {
                hideLoading();
                input.value = '';
            }
        }

        // 2. 갤러리 다중 업로드
        async function uploadGalleryImages(input) {
            if (!input.files || input.files.length === 0) return;
            const files = Array.from(input.files);
            let successCount = 0;
            
            // ★ 미리보기용 Base64를 저장할 배열
            const tempPreviews = [];

            try {
                for (let i = 0; i < files.length; i++) {
                    showLoading(`갤러리 업로드 중... (${i + 1}/${files.length})`);
                    const file = files[i];
                    
                    // 1. Base64 변환
                    const base64Content = await toBase64(file);
                    tempPreviews.push(base64Content); // 순서대로 저장

                    // 2. 업로드
                    const fileName = `images/${new Date().getTime()}_${i}_${file.name}`;
                    const uploadedUrl = await uploadFileToGitHub(fileName, base64Content);
                    
                    // 3. 데이터에 URL 추가 (맨 앞에)
                    portfolioData.gallery.unshift(uploadedUrl);
                    successCount++;
                }
                
                // 4. 렌더링
                renderGallery();

                // ★ 핵심: 방금 추가된 맨 앞 이미지들을 Base64로 강제 교체
                const galleryItems = document.querySelectorAll('.gallery-item img');
                // 최신순으로 추가되므로, 앞쪽 인덱스가 방금 올린 파일임
                // tempPreviews는 [파일1, 파일2...] 순서이므로, 
                // 갤러리의 맨 앞(가장 최신)부터 역순으로 매칭해야 함.
                
                // 예: 파일 2개를 올렸다면 gallery[0], gallery[1]이 방금 올린 것.
                // gallery[0]은 files[1](나중에 처리됨), gallery[1]은 files[0]
                
                // 간단하게: 갤러리를 다시 그릴 때, 아직 로딩 안 된 URL은 엑박이 뜸.
                // 방금 올린 개수만큼(successCount) 루프를 돌면서 src를 바꿔치기함.
                for(let i=0; i < successCount; i++) {
                    if(galleryItems[i]) {
                        // tempPreviews 배열은 순차적으로 쌓였지만, gallery는 unshift로 역순으로 쌓임
                        // 따라서 tempPreviews의 마지막 요소가 gallery의 0번임
                        galleryItems[i].src = tempPreviews[tempPreviews.length - 1 - i];
                    }
                }

                alert(`${successCount}장의 이미지가 업로드되었습니다.`);
            } catch (err) {
                alert("일부 업로드 실패: " + err.message);
            } finally {
                hideLoading();
                input.value = '';
            }
        }

        /* --- [GitHub 통신 함수] --- */
        async function forceLoadFromGitHub(silent = false) {
            if(!ghConfig.owner || !ghConfig.token) return;
            if(!silent) showLoading("GitHub 데이터 불러오는 중...");
            const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/data.js?ref=main&timestamp=${new Date().getTime()}`;
            try {
                const res = await fetch(url, { headers: { Authorization: `token ${ghConfig.token}` } });
                if(!res.ok) throw new Error("불러오기 실패");
                const json = await res.json();
                const content = decodeURIComponent(escape(window.atob(json.content)));
                const jsonStr = content.replace('const portfolioData =', '').replace(';', '');
                portfolioData = JSON.parse(jsonStr);
                initAdmin();
                const statusBadge = document.getElementById('syncStatus');
                statusBadge.textContent = "Synced with GitHub"; statusBadge.classList.add('active');
                if(!silent) alert("동기화 완료!");
            } catch(err) { console.error(err); if(!silent) alert("데이터 로드 실패"); } finally { hideLoading(); }
        }

        async function uploadFileToGitHub(path, content) {
            if(!ghConfig.owner || !ghConfig.token) throw new Error("GitHub 설정 필요");
            const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/${path}`;
            const cleanContent = content.split(',')[1];
            const res = await fetch(url, { method: 'PUT', headers: { Authorization: `token ${ghConfig.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ message: `Upload image: ${path}`, content: cleanContent }) });
            if (!res.ok) throw new Error(res.statusText);
            // CDN 캐시 우회를 위해 타임스탬프를 붙이지 않고 원본 URL 반환 (사이트에선 1~3분 뒤 뜸)
            return `https://${ghConfig.owner}.github.io/${ghConfig.repo}/${path}`;
        }

        async function saveDataJsToGitHub() {
            if(!ghConfig.owner || !ghConfig.token) return alert("설정 필요"); showLoading("데이터 저장 중...");
            const content = "const portfolioData = " + JSON.stringify(portfolioData, null, 4) + ";";
            const contentEncoded = btoa(unescape(encodeURIComponent(content)));
            const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/data.js`;
            try {
                const getRes = await fetch(url, { headers: { Authorization: `token ${ghConfig.token}` } });
                const getData = await getRes.json();
                const putRes = await fetch(url, { method: 'PUT', headers: { Authorization: `token ${ghConfig.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ message: `Update data.js`, content: contentEncoded, sha: getData.sha }) });
                if(putRes.ok) alert("저장 완료! (1~3분 후 반영됩니다)"); else alert("저장 실패");
            } catch(err) { alert("오류: " + err); } finally { hideLoading(); }
        }

        function toBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        /* --- [자동 번역] --- */
        async function runAutoTranslate(index, fieldType) {
            const item = portfolioData.filmography[index];
            const sourceText = item[fieldType].en || item[fieldType].ko;
            if (!sourceText) { alert("KO 또는 EN 내용이 있어야 합니다."); return; }
            if (!confirm(`[${sourceText}] 내용으로 자동 번역하시겠습니까?`)) return;
            showLoading("자동 번역 중...");
            const targets = ['cn', 'ja', 'pt', 'es', 'ar'];
            try {
                for (const lang of targets) {
                    let apiLang = lang === 'cn' ? 'zh-CN' : lang;
                    const translated = await fetchTranslation(sourceText, apiLang);
                    portfolioData.filmography[index][fieldType][lang] = translated;
                    const inputEl = document.getElementById(`input-${index}-${fieldType}-${lang}`);
                    if (inputEl) inputEl.value = translated;
                }
                alert("번역 완료!");
            } catch (err) { alert("번역 오류: " + err.message); } finally { hideLoading(); }
        }
        async function fetchTranslation(text, targetLang) {
            const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=en|${targetLang}`;
            try { const res = await fetch(url); const data = await res.json(); return data.responseData ? data.responseData.translatedText : ""; } 
            catch (e) { console.error(e); return ""; }
        }

        /* --- [히스토리] --- */
        async function loadHistory() {
            if(!ghConfig.owner || !ghConfig.token) return alert("설정 필요");
            showLoading("히스토리 로드...");
            const list = document.getElementById('historyList'); list.innerHTML = '';
            const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/commits?path=data.js`;
            try {
                const res = await fetch(url, { headers: { Authorization: `token ${ghConfig.token}` } });
                const commits = await res.json();
                commits.forEach(commit => {
                    const date = new Date(commit.commit.author.date).toLocaleString();
                    const msg = commit.commit.message;
                    const sha = commit.sha;
                    const li = document.createElement('li');
                    li.className = 'history-item';
                    li.innerHTML = `<div class="history-info"><div>${msg}</div><span>${date}</span></div><button class="btn btn-outline" onclick="restoreVersion('${sha}')">복구</button>`;
                    list.appendChild(li);
                });
                document.getElementById('historyModal').style.display = 'flex';
            } catch(err) { alert("실패: " + err); } finally { hideLoading(); }
        }
        async function restoreVersion(sha) {
            if(!confirm("복구하시겠습니까?")) return; showLoading("복구 중...");
            const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/data.js?ref=${sha}`;
            try {
                const res = await fetch(url, { headers: { Authorization: `token ${ghConfig.token}` } });
                const data = await res.json();
                const content = decodeURIComponent(escape(window.atob(data.content)));
                const jsonStr = content.replace('const portfolioData =', '').replace(';', '');
                portfolioData = JSON.parse(jsonStr);
                initAdmin(); closeHistory(); alert("복구됨! 저장 버튼을 눌러 확정하세요.");
            } catch(err) { alert("실패: " + err); } finally { hideLoading(); }
        }
        function closeHistory() { document.getElementById('historyModal').style.display = 'none'; }

        /* --- [렌더링 & UI] --- */
        function renderGallery() { document.getElementById('galleryContainer').innerHTML = portfolioData.gallery.map((url, i) => `<div class="gallery-item"><img src="${url}"><button class="remove-btn" onclick="portfolioData.gallery.splice(${i},1); renderGallery();">×</button></div>`).join(''); }
        
        function renderFilmoGroups() {
            const container = document.getElementById('filmoContainer'); container.innerHTML = '';
            const groups = {}; CATEGORY_ORDER.forEach(cat => groups[cat] = []);
            portfolioData.filmography.forEach((item, index) => { item._originIndex = index; if (!groups[item.category]) groups[item.category] = []; groups[item.category].push(item); });
            Object.keys(groups).forEach(cat => {
                const section = document.createElement('section'); section.className = 'category-section';
                section.innerHTML = `<div class="category-header"><span class="category-title">${cat}</span></div><button class="btn-add-section" onclick="addFilmo('${cat}')">+ Add to <b>${cat}</b></button><div class="filmo-list"></div>`;
                const list = section.querySelector('.filmo-list');
                if(groups[cat].length === 0) list.innerHTML = `<div class="empty-message">작품 없음</div>`;
                else groups[cat].forEach(item => list.appendChild(createFilmoItem(item)));
                container.appendChild(section);
            });
        }

        function createFilmoItem(item) {
            const el = document.createElement('div'); el.className = 'filmo-item'; el.draggable = true; el.dataset.originIndex = item._originIndex;
            el.addEventListener('dragstart', dragStart); el.addEventListener('dragend', dragEnd);
            const createLangInputs = (type) => LANG_LIST.map(lang => `<div class="lang-item"><label>${LANG_LABEL[lang]} (${lang.toUpperCase()})</label><input type="text" id="input-${item._originIndex}-${type}-${lang}" value="${item[type][lang] || ''}" onchange="portfolioData.filmography[${item._originIndex}].${type}.${lang}=this.value"></div>`).join('');
            el.innerHTML = `
                <div class="filmo-summary" onclick="if(!event.target.classList.contains('drag-handle')) this.parentElement.classList.toggle('active')">
                    <div class="drag-handle">≡</div>
                    <img src="${item.thumb}" class="thumb-preview">
                    <div class="info-preview">
                        <div style="font-weight:bold">${item.title.ko || '(제목)'}</div>
                        <div style="font-size:0.8rem; color:#888">${item.year} | ${item.role.ko}</div>
                    </div>
                    <div>▼</div>
                </div>
                <div class="filmo-details">
                    <div style="text-align:right"><button class="btn btn-danger" onclick="deleteFilmo(${item._originIndex})">삭제</button></div>
                    <div class="form-group" style="background:#f9f9f9; padding:10px; border-radius:6px;"><label>기본 정보</label><div style="display:flex; gap:10px; margin-bottom:10px;"><div style="flex:1"><label>연도</label><input type="text" value="${item.year}" onchange="portfolioData.filmography[${item._originIndex}].year=this.value"></div><div style="flex:1"><label>방송사</label><input type="text" value="${item.broadcast}" onchange="portfolioData.filmography[${item._originIndex}].broadcast=this.value"></div></div><div style="display:flex; gap:10px; align-items:center;"><img src="${item.thumb}" class="preview-img" style="width:60px; height:90px; margin:0;"><div style="flex:1"><label>포스터 변경</label><input type="file" accept="image/*" onchange="uploadImage(this, 'thumb', ${item._originIndex})"></div></div></div>
                    <div class="form-group"><div class="label-row"><label style="margin:0">제목 (Title)</label><button class="btn-auto-trans" onclick="runAutoTranslate(${item._originIndex}, 'title')">⚡ 자동 번역</button></div><div class="lang-grid">${createLangInputs('title')}</div></div>
                    <div class="form-group"><div class="label-row"><label style="margin:0">역할 (Role)</label><button class="btn-auto-trans" onclick="runAutoTranslate(${item._originIndex}, 'role')">⚡ 자동 번역</button></div><div class="lang-grid">${createLangInputs('role')}</div></div>
                </div>`;
            return el;
        }

        function addFilmo(cat) { const emptyLangObj = {}; LANG_LIST.forEach(lang => emptyLangObj[lang] = ""); portfolioData.filmography.unshift({ category: cat, year: new Date().getFullYear(), thumb: "https://placehold.co/200", broadcast:"", title: { ...emptyLangObj, ko: "새 작품" }, role: { ...emptyLangObj } }); renderFilmoGroups(); }
        function deleteFilmo(i) { if(confirm('삭제?')) { portfolioData.filmography.splice(i, 1); renderFilmoGroups(); } }

        // 드래그
        let draggedItem = null;
        function dragStart(e) { draggedItem = this; this.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; }
        function dragEnd() { this.classList.remove('dragging'); draggedItem = null; const newOrder = []; document.querySelectorAll('.filmo-item').forEach(el => { newOrder.push(portfolioData.filmography[el.dataset.originIndex]); }); portfolioData.filmography = newOrder; renderFilmoGroups(); }
        document.querySelectorAll('.filmo-list').forEach(list => { list.addEventListener('dragover', e => { e.preventDefault(); const afterElement = getDragAfterElement(list, e.clientY); if (draggedItem) { if (afterElement == null) list.appendChild(draggedItem); else list.insertBefore(draggedItem, afterElement); } }); });
        function getDragAfterElement(container, y) { const draggableElements = [...container.querySelectorAll('.filmo-item:not(.dragging)')]; return draggableElements.reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2; if (offset < 0 && offset > closest.offset) return { offset: offset, element: child }; else return closest; }, { offset: Number.NEGATIVE_INFINITY }).element; }

        function showLoading(msg) { document.getElementById('loadingText').textContent = msg; document.getElementById('loadingSpinner').style.display = 'flex'; }
        function hideLoading() { document.getElementById('loadingSpinner').style.display = 'none'; }
    </script>
</body>
</html>